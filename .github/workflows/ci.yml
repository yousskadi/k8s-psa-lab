# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# .github/workflows/ci.yml
#
# FONCTIONNEMENT GÃ‰NÃ‰RAL :
#
#   Chaque push ou PR dÃ©clenche ce pipeline composÃ© de 3 jobs exÃ©cutÃ©s
#   dans l'ordre suivant (grÃ¢ce au mot-clÃ© "needs") :
#
#   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”‚  lint   â”‚â”€â”€â”€â”€â–¶â”‚ integration-tests  â”‚â”€â”€â”€â”€â–¶â”‚ compliance-reportâ”‚
#   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
#   Si "lint" Ã©choue       â†’ "integration-tests" ne dÃ©marre pas
#   Si "integration-tests" â†’ "compliance-report" ne dÃ©marre pas
#
# POURQUOI KIND FONCTIONNE SUR GITHUB ACTIONS SANS CONFIG SPÃ‰CIALE :
#
#   GitHub Actions fournit une VM Ubuntu dÃ©diÃ©e par job (runs-on: ubuntu-latest)
#   Cette VM a Docker prÃ©-installÃ© et configurÃ©.
#   Kind crÃ©e ses "nÅ“uds" Kubernetes sous forme de containers Docker directement
#   sur cette VM â†’ pas besoin de Docker-in-Docker (DinD) ni de privileged mode.
#   Contrairement Ã  GitLab CI oÃ¹ le job tourne dans un container,
#   ici le job tourne dans une vraie VM â†’ Docker est disponible nativement.
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: PSA Lab CI

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DÃ‰CLENCHEURS
# Le pipeline se lance automatiquement dans ces situations :
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
on:
  # Bouton "Run workflow" manuel dans l'onglet Actions sur GitHub
  # Utile pour tester sans avoir Ã  faire un commit
  workflow_dispatch:

  push:
    branches:
      - main       # Chaque push sur main (ex: merge d'une PR)
      - develop    # Chaque push sur develop
    # Pas de filtre paths ici : le projet est Ã  la racine du repo
    # donc tout push sur main/develop est pertinent

  pull_request:
    branches:
      - main       # Chaque PR qui cible main (avant le merge)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VARIABLES GLOBALES
# Accessibles dans tous les jobs via ${{ env.NOM_VARIABLE }}
# CentralisÃ©es ici pour faciliter les mises Ã  jour de version
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
env:
  KIND_VERSION: v0.20.0
  KUBECTL_VERSION: v1.28.0
  # Nom unique par run pour Ã©viter les conflits si plusieurs pipelines
  # tournent en parallÃ¨le â€” github.run_id est un entier unique par exÃ©cution
  CLUSTER_NAME: psa-ci-${{ github.run_id }}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# NOTE : pas de "defaults.run.working-directory" ici car le projet
# est directement Ã  la racine du repo â†’ tous les chemins relatifs
# (manifests/, scripts/, tests/, kind/) fonctionnent sans prÃ©fixe
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# JOB 1 : LINT
# Objectif : vÃ©rifier la syntaxe des fichiers YAML et du chart Helm
#            AVANT de crÃ©er un cluster (rapide et peu coÃ»teux ~30s)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
jobs:
  lint:
    name: "Lint YAML & Helm"
    runs-on: ubuntu-latest   # VM Ubuntu fournie par GitHub (2 CPU, 7 Go RAM)

    steps:
      # Clone le repo dans /home/runner/work/<repo>/<repo>/
      # Toutes les Ã©tapes suivantes travaillent depuis cette racine
      - name: Checkout
        uses: actions/checkout@v4

      # yamllint est un linter Python pour la syntaxe YAML
      # DÃ©tecte les erreurs d'indentation, tabulations, etc.
      - name: Install yamllint
        run: pip install yamllint

      # -d relaxed : mode permissif (pas de rÃ¨gles strictes sur longueur des lignes)
      # || true : ne pas faire Ã©chouer le job sur les warnings (non-bloquant)
      # On ne lint pas helm/ car les templates {{ }} ne sont pas du YAML valide
      - name: Lint YAML
        run: yamllint -d relaxed manifests/ kind/ || true

      # azure/setup-helm est l'action recommandÃ©e pour installer Helm sur la VM
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.13.0

      # helm lint vÃ©rifie : Chart.yaml valide, templates syntaxiquement corrects,
      # values.yaml cohÃ©rent â€” --strict traite les warnings comme des erreurs
      - name: Lint Helm chart
        run: |
          helm lint ./helm/psa-namespace --strict
          echo "âœ… Helm lint OK"

      # helm template gÃ©nÃ¨re les manifests YAML finaux sans les appliquer
      # VÃ©rifie que les templates se rendent bien avec des valeurs rÃ©elles
      # DiffÃ©rent de helm lint : ici on teste le rendu concret
      - name: Helm template dry-run
        run: |
          helm template test-ns ./helm/psa-namespace \
            --set namespaceName=helm-test \
            --set podSecurity.enforce=restricted \
            --set podSecurity.version=v1.28
          echo "âœ… Helm template OK"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2 : TESTS D'INTÃ‰GRATION
  # Objectif : crÃ©er un vrai cluster Kubernetes avec Kind et exÃ©cuter
  #            les tests PSA pour valider que tout fonctionne end-to-end
  # DurÃ©e estimÃ©e : ~3-4 minutes (la majoritÃ© en crÃ©ation du cluster)
  # DÃ©pendance : attend que "lint" rÃ©ussisse avant de dÃ©marrer
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  integration-tests:
    name: "PSA Integration Tests (Kind)"
    runs-on: ubuntu-latest
    needs: lint   # Ce job ne dÃ©marre QUE si "lint" a rÃ©ussi (exit 0)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # helm/kind-action est l'action officielle pour Kind sur GitHub Actions
      # Elle installe Kind + kubectl, crÃ©e le cluster, configure le kubeconfig
      #
      # config: kind/cluster-simple.yaml
      #   â†’ 1 seul nÅ“ud control-plane (plus rapide en CI que multinode)
      #   â†’ chemin depuis la racine du repo, pas de prÃ©fixe nÃ©cessaire
      #
      # wait: 120s â†’ attend que les nÅ“uds soient Ready avant de continuer
      #   Sans Ã§a, les pods systÃ¨me (coredns) ne seraient pas encore dÃ©marrÃ©s
      #   et les Ã©tapes suivantes pourraient Ã©chouer
      - name: Setup Kind + kubectl
        uses: helm/kind-action@v1
        with:
          version: ${{ env.KIND_VERSION }}
          cluster_name: ${{ env.CLUSTER_NAME }}
          config: kind/cluster-simple.yaml
          kubectl_version: ${{ env.KUBECTL_VERSION }}
          wait: 120s

      # Ã‰tape de diagnostic : affiche l'Ã©tat du cluster dans les logs
      # --context kind-<nom> : Ãªtre explicite sur quel cluster on interroge
      - name: Verify cluster is ready
        run: |
          kubectl cluster-info --context kind-${{ env.CLUSTER_NAME }}
          kubectl get nodes -o wide
          kubectl get pods -A

      # jq est utilisÃ© dans nos scripts bash pour parser le JSON kubectl
      # (audit-namespaces.sh et check-compliance.sh en ont besoin)
      - name: Install jq
        run: sudo apt-get install -y jq

      # Git ne prÃ©serve pas toujours les permissions +x
      # Cette Ã©tape garantit que tous les scripts .sh sont exÃ©cutables
      - name: Make scripts executable
        run: chmod +x scripts/*.sh tests/*.sh

      # VÃ©rifie : namespace monitoring-privileged avec enforce=privileged,
      # workloads avec hostNetwork/hostPID acceptÃ©s, exception documentÃ©e
      - name: Run Lab 1 tests (Privileged)
        run: ./tests/test-lab1-privileged.sh

      # VÃ©rifie : namespace app-baseline avec enforce=baseline,
      # pods conformes crÃ©Ã©s, pods avec hostNetwork REFUSÃ‰S
      - name: Run Lab 2 tests (Baseline)
        run: ./tests/test-lab2-baseline.sh

      # VÃ©rifie : namespace app-restricted avec enforce=restricted,
      # pods sans seccomp/capabilities/runAsNonRoot REFUSÃ‰S,
      # pods correctement configurÃ©s crÃ©Ã©s et Running
      - name: Run Lab 3 tests (Restricted)
        run: ./tests/test-lab3-restricted.sh

      # Affiche un tableau rÃ©capitulatif de tous les namespaces
      # avec leurs politiques PSA enforce/audit/warn dans les logs CI
      - name: Audit all namespaces
        run: ./scripts/audit-namespaces.sh

      # --server-side : validation cÃ´tÃ© API server (plus prÃ©cise que client-side)
      # --dry-run=server : simule l'apply sans rien crÃ©er ni modifier
      # DÃ©tecte les erreurs que --dry-run=client ne verrait pas
      - name: Dry-run namespaces server-side
        run: |
          kubectl apply -f manifests/00-namespaces/ --server-side --dry-run=server
          echo "âœ… Dry-run namespaces OK"

      # Helm n'est pas partagÃ© entre les jobs (chaque job = VM isolÃ©e)
      # Il faut le rÃ©installer dans ce job
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.13.0

      # --dry-run --debug contre un vrai cluster (pas juste helm template)
      # VÃ©rifie que Helm peut communiquer avec l'API server Kubernetes
      # et que les ressources gÃ©nÃ©rÃ©es sont valides selon K8s
      - name: Helm install dry-run
        run: |
          helm install test-ns ./helm/psa-namespace \
            --set namespaceName=helm-test \
            --set podSecurity.enforce=restricted \
            --set podSecurity.version=v1.28 \
            --dry-run --debug
          echo "âœ… Helm dry-run OK"

      # if: failure() â†’ s'exÃ©cute UNIQUEMENT si une Ã©tape prÃ©cÃ©dente a Ã©chouÃ©
      # Les logs Kind aident Ã  diagnostiquer les problÃ¨mes de cluster
      # L'artifact est tÃ©lÃ©chargeable depuis l'onglet Summary pendant 3 jours
      - name: Upload logs si Ã©chec
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: kind-logs-${{ github.run_id }}
          path: /tmp/kind-logs/
          retention-days: 3

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3 : RAPPORT DE CONFORMITÃ‰
  # Objectif : gÃ©nÃ©rer un tableau rÃ©capitulatif visible dans l'onglet
  #            "Summary" du workflow sur GitHub (rendu Markdown, pas les logs)
  # DurÃ©e estimÃ©e : ~10 secondes
  # Condition : uniquement sur main â€” rapport "officiel" de la branche stable
  #             Sur une PR, github.ref = refs/pull/N/merge â†’ condition false
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  compliance-report:
    name: "Compliance Report"
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # $GITHUB_STEP_SUMMARY est un fichier Markdown spÃ©cial GitHub Actions
      # Tout ce qu'on Ã©crit dedans apparaÃ®t dans l'onglet "Summary" du workflow
      # C'est mis en forme visuellement (tableaux, titres, emojis rendus)
      # contrairement aux logs bruts
      #
      # Le script parse chaque YAML de manifests/00-namespaces/ avec grep+awk
      # et construit un tableau avec emoji selon le niveau PSA :
      #   ğŸŸ¢ restricted  = sÃ©curitÃ© maximale
      #   ğŸŸ¡ baseline    = sÃ©curitÃ© minimale
      #   ğŸ”´ privileged  = aucune restriction (exception documentÃ©e)
      - name: Generate compliance summary
        run: |
          echo "## ğŸ” PSA Compliance Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | Enforce | Audit | Warn |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|:-------:|:-----:|:----:|" >> $GITHUB_STEP_SUMMARY
          find manifests/00-namespaces/ -name '*.yaml' | sort | while read f; do
            NS=$(grep "name:" "$f" | head -1 | awk '{print $2}')
            ENF=$(grep "enforce:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            AUD=$(grep "audit:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            WRN=$(grep "warn:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            case "$ENF" in
              restricted)  ICON="ğŸŸ¢" ;;
              baseline)    ICON="ğŸŸ¡" ;;
              privileged)  ICON="ğŸ”´" ;;
              *)           ICON="âšª" ;;
            esac
            echo "| \`$NS\` | $ICON $ENF | $AUD | $WRN |" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Pipeline complet â€” tous les tests ont passÃ©" >> $GITHUB_STEP_SUMMARY
